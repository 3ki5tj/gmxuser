Source code
===========
This note applies to one of the following file
  * programs/mdrun/md.cpp (v5.1 or later)
  * programs/mdrun/md.c (v5.0)
  * kernel/md.c (v4.6 or earlier)



do_md() function
=======================
* main MD loop: ``while (!bLastStep ...) {''
  * on lines 693-1889 (v4.5).


Review of integrators
---------------------

### leapfrog integrators

 v += (f/m) dt
 x += v dt

This is what `update_coords()` does.


### velocity-verlet integrators

 v += (f/m) (dt/2)      etrtVELOCITY2
 x += v dt              etrtPOSITIION
 v += (f/m) (dt/2)      etrtVELOCITY1



Flow of main steps
-------------------

 *  `do_force()`
 *  `if (bVV) update_coords( etrtVELOCITY1 )`
     o  `do_update_vv_vel()`
     o  second half VV step of the previous step
     o  v += (f/m) dt/2
 *  `do_md_trajectory_writing()`
     o  defined in `gromacs/fileio/trajectory_writing.c`
     o  calls `mdoutf_write_to_trajectory_files()`
         *  defined in `gromacs/fileio/mdoutf.c`.
         *  collect state, x, v, f.
         *  Below are important calls.
         *  dd_collect_state(state_local, state_global);
            on the master, state_global->x, ->v, ->box is syncronized
            or alternatively
              dd_collect_vec(state_local->x, state_global->x);
              dd_collect_vec(local_v, global_v);
            where local_v  == state_local->v,
                  global_v == state_global->v
         *  dd_collect_vec(f_local, f_global);
 *  `update_tcouple()`
     o  compute the velocity scaling factor, `ekind->tcstat[i].lambda`
     o  doesn't actually touch the velocity array
 *  `if (bVV) update_coords( etrtVELOCITY2 )`
     o  `do_update_vv_vel()`
     o  first half VV step of this step
     o  v += (f/m) dt/2
 *  `update_coords( etrtPOSITION )`
     o  for leapfrog:
        *   `do_update_md()`
        *   v += (f/m) dt
        *   x += v dt
        *   update velocity (overwrite), apply the scaling factor, and add the accelecration
        *   update coordinates, save the new coordinates to `xprime`, which is `upd->xp`
     o  for VV:
        *   `do_update_vv_pos()`
        *   x += v dt
 *  `update_constraints()`



Arguments and variables
-----------------------

  t_state *state_global;
  t_commrec *cr;
  gmx_vsite_t *vsite;
  gmx_constr_t constr;
  gmx_top_t *top_global;
  t_fcdata *fcd;
  t_mdatoms *mdatoms;
  t_inputrec *ir;
  t_forcerec *fr;

trivial ones
  * t_filenm fnm[nfile];          file names,
  * gmx_wallcycle_t wcycle;       mdlib/gmx_wallcycle.c
  * output_env_t oenv;


replica exchange variables
--------------------------
state_global
enerd->term
state



`top_global`
--------------

used to create
  `top_global` --> `top`


`top_global` is used in

  init_md(top_global);
  init_enerdata(top_global);
  top = dd_init_local_top(top_global);
  dd_partition_system(top_global, top);
  compute_globals(top_global)


`top` is used in

  dd_partition_system(top);
  set_constraints(top);               before main loop
  do_constrain_first(top);            before main loop
  update_coords(&top->idef);
  update_costrains(&top->idef);




reset_all_counters() function
=============================
* static function
* reset `wcycle` properties
* set `step_rel` to 0.



