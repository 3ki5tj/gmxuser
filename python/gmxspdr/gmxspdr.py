#!/usr/bin/env python

'''
build a self-contained C file as a GROMACS engine
basically it grabs several key files from the GROMACS source tree and
writes an output `mdfoo.c' based on an optional input template `foo.h'
details can be found in the function usage(), or run the script with `-h'
'''

import re, sys, os, glob, getopt
from ccgmx import CCGMX
from ccutil import savelines, tmptagrep
import gmxcom

objname = None  # nick name of the object variable
prefix = None   # function prefix, "gmx" + `objname' by default
fninp = None    # input template file name
fnout = None    # output .c file name

# a universal header to be inserted at the beginning of the file
txtdecl = r'''/* generated by gmxspdr.py from %input_file% */
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#define GMXVERSION %gmx_version%
%gmx_large_int_t%

#include <string.h>
#include <signal.h>
#include "typedefs.h"
#include "physics.h"
#include "smalloc.h"
#include "network.h"
#include "vsite.h"

#ifdef GMX_LIB_MPI
#include <mpi.h>
#endif
#ifdef GMX_THREADS
#include "tmpi.h"
#endif

#ifndef RETSIGTYPE
#define RETSIGTYPE void
#endif

/* declare `%pfx%_t' as a pointer to some struct */
typedef struct tag%pfx%_t %pfx%_t;

/* the actual functions are to be defined in the template */

/* the initialization function called in %pfx%_runner()
   before %pfx%_domd()/gmx_pmeonly() */
static %pfx%_t *%pfx%_init(const char *fncfg, unsigned contnu,
    t_state *state, gmx_mtop_t *mtop, t_inputrec *ir, t_commrec *cr,
    int mode);

/* the final function called at the end of %pfx%_runner() */
static void %pfx%_done(%pfx%_t *%obj%, t_commrec *cr);

/* the function called after each MD step, in %pfx%_domd()
 * after replica_change(), only a PP-node calls this */
static int %pfx%_move(%pfx%_t *%obj%, FILE *fplog,
    gmx_large_int_t step, int bFirstStep, int bLastStep,
    int bGStat, int bXTC, int bNS, gmx_enerdata_t *enerd,
    t_state *state_global, t_state *state_local, rvec **f,
    gmx_mtop_t *top_global, gmx_localtop_t *top_local,
    t_inputrec *ir, t_commrec *cr, t_mdatoms *mdatoms, t_forcerec *fr,
    gmx_vsite_t *vsite, gmx_shellfc_t shellfc, gmx_constr_t constr,
    t_nrnb *nrnb, gmx_wallcycle_t wcycle);

/* a helper function to handle the input .cfg file */
static char *%pfx%_opt2fn(const char *opt, int nfile, const t_filenm fnm[])
{
  int i;
  for (i = 0; i < nfile; i++)
    if (strcmp(opt, fnm[i].opt) == 0) { /* a match is found */
      char *fn = fnm[i].fns[0], *p;
      if (fnm[i].ftp == efMDP) {
        /* modify the extension from .mdp to .cfg */
        if (strcmp(fn, "grompp.mdp") == 0) { /* replace the default name by NULL */
          return NULL; /* we do not have default name for .cfg files */
        } else if ((p = strstr(fn, ".cfg.mdp")) != NULL) {
          p[4] = '\0';
        } else if ((p = strstr(fn, ".mdp")) != NULL) {
          strcpy(p, ".cfg");
        }
      }
      return fn;
    }
  return NULL;
}
'''



# default input template file
txtinp = '''
/* %OBJ_DECL% */

typedef struct tag%pfx%_t {
  int mode;
} %pfx%_t;

static %pfx%_t *%pfx%_init(const char *fncfg, unsigned contnu,
    t_state *state, gmx_mtop_t *mtop, t_inputrec *ir, t_commrec *cr,
    int mode)
{
  %pfx%_t *%obj%;
  if (!(cr->duty & DUTY_PP)) return NULL; /* skip a PME-only node */
  snew(%obj%, 1);
  %obj%->mode = mode;
  if (PAR(cr)) gmx_bcast(sizeof(*%obj%), %obj%, cr);
  return %obj%;
}

static void %pfx%_done(%pfx%_t *%obj%, t_commrec *cr)
{
  if (%obj% != NULL) free(%obj%);
}

static int %pfx%_move(%pfx%_t *%obj%, FILE *fplog,
    gmx_large_int_t step, int bFirstStep, int bLastStep,
    int bGStat, int bXTC, int bNS, gmx_enerdata_t *enerd,
    t_state *state_global, t_state *state_local, rvec **f,
    gmx_mtop_t *top_global, gmx_localtop_t *top_local,
    t_inputrec *ir, t_commrec *cr, t_mdatoms *mdatoms, t_forcerec *fr,
    gmx_vsite_t *vsite, gmx_shellfc_t shellfc, gmx_constr_t constr,
    t_nrnb *nrnb, gmx_wallcycle_t wcycle)
{
  return 0; /* not moved */
}

/* %bondfree.c% */
/* %force.c% */
/* %sim_util.c% */
/* %md.c% */
/* %runner.c% */
/* %mdrun.c% */
'''



def usage():
  ''' print usage and die '''
  print "%s [OPTIONS] prj" % sys.argv[0]

  print '''
  The program grabs several core GROMACS files, and writes
  a self-contained C file, which can be compiled almost independently
  Optionally, it reads an input template file `foo.h',
  and then outputs `mdfoo.c', in which the functional tags, such as
  %MDRUN_C% are replaced by the relevant functions in the corresponding
  GROMACS source code (`mdrun.c').

  If `prj' is a file name, the extension is removed automatically
  The "gmx"+`prj'+"_" will be used as the default prefix
  '''

  print '''
  OPTIONS:
  -b, --object:   specify object name
  -p, --prefix:   specify function prefix
  -i, --input:    specify input file name
  -o, --output:   specify output file name
  -h, --help:     print this message
  '''
  exit(1)



def doargs():
  ''' Handle args '''
  global objname, prefix, fninp, fnout, txtinp

  try:
    opts, args = getopt.gnu_getopt(sys.argv[1:],
        "hv:b:p:i:o:",
        ["help",
         "object=", "obj=",
         "prefix=", "pfx=",
         "input=", "output="] )
  except getopt.GetoptError, err:
    # print help information and exit
    print str(err) # will print something like "option -a not recognized"
    usage()

  fninp = None # unset the default file name
  for o, a in opts:
    if o in ("--dummy",):
      pass
    elif o in ("-b", "--object", "--obj"):
      objname = a
    elif o in ("-p", "--prefix", "--pfx"):
      prefix = a
    elif o in ("-i", "--input"):
      fninp = a
    elif o in ("-o", "--output"):
      fnout = a
    elif o in ("-h", "--help"):
      usage()

  if len(args) > 0 and fninp == None:
    fninp = args[0]

  # guess the object name
  if objname == None and fninp != None:
    objname = fninp
    if objname.startswith("md"):  # remove the default prefix `md'
      objname = objname[2:]
    i = objname.find(".") # in case the object name
                          # is given as a file name
    if i >= 0: objname = objname[:i]

  # guess the input file name,
  if fninp == None and objname != None:
    ls = glob.glob(objname + ".[hc]")
    if len(ls) > 0: fninp = ls[0]

  # running the demonstration
  if objname == None and fninp == None:
    print "no object name, running the demonstration ..."
    objname = "foo"

  # read the input file as template, otherwise use the default
  if fninp != None:
    txtinp = open(fninp).read()

  if not fnout:
    fnout = "md" + objname + ".c"

  print "object %s, prefix %s, input %s, output %s" % (
      objname, prefix, fninp, fnout)



def main():
  ''' main function '''
  doargs()

  obj = objname
  pfx = prefix
  hdrs = {}

  gmxver = gmxcom.version()

  # create an empty CCGMX object to assign prefix
  # better mechanism?
  decl = CCGMX(None, None, obj, pfx, hdrs)
  slargeint = ""
  if gmxver < 40100:
    slargeint = "typedef long int gmx_large_int_t;"
  # supply two additional keys
  d = { "%input_file%": str(fninp),
        "%gmx_version%": str(gmxver),
        "%gmx_large_int_t%": slargeint, }
  # replace %pfx%, etc
  txthdr = decl.temprepl(txtdecl, True, d)
  # recreate the decl object
  decl = CCGMX(None, txthdr, obj, pfx, hdrs)
  decl.shdr()

  if gmxver < 40010:
    import ccmdxv40 as ccmdx
  else:
    import ccmdx
    if gmxver >= 40600:
      print "Warning: this version", gmxver, "of GROMACS is unsupported"
      #raise Exception


  # change %obj%, %pfx%, etc., in the input template file
  global txtinp
  txtinp = decl.temprepl(txtinp, True, d);

  # set filenames to `None' to be safe
  bondfree_c = ccmdx.get_bondfree_c(txtinp, obj, pfx, hdrs)
  force_c = ccmdx.get_force_c(txtinp, obj, pfx, hdrs)
  simutil_c = ccmdx.get_simutil_c(txtinp, obj, pfx, hdrs)

  md_c = ccmdx.get_md_c(txtinp, obj, pfx, hdrs)
  runner_c = ccmdx.get_runner_c(txtinp,obj, pfx, hdrs)
  mdrun_c = ccmdx.get_mdrun_c(txtinp, obj, pfx, hdrs)

  # replace user-supplied tags
  dic = {
    "%obj.decl%"    : decl.s,
    "%bondfree.c%"  : bondfree_c,
    "%force.c%"     : force_c,
    "%sim_util.c%"  : simutil_c,
    "%md.c%"        : md_c,
    "%runner.c%"    : runner_c,
    "%mdrun.c%"     : mdrun_c,
  }
  code = tmptagrep(txtinp, dic)

  savelines(fnout, code)


if __name__ == "__main__":
  # try to accelerate the process
  try:
    import psyco
    psyco.full()
  except ImportError: pass

  main()

